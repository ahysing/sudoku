<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../../bower_components/iron-validator-behavior/iron-validator-behavior.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rek="import" href="../sudoku-block/sudoku-block.html">
<dom-module id="sudoku-section">
  <template>
    <style>
      :host {
        display: block;
      }
      .invalid {
        border: 3px;
        background-color: pink;
      }
      .section {
        @apply --layout-horizontal;
        @apply --layout-wrap;
        border: 3px;
      }
      .size-2 {
        width: 80px;
      }
      .size-3 {
        width: 120px;
      }
      .size-4 {
        width: 160px;
      }
      
    </style>
    <div class="section">
      <template is="dom-repeat" items="{{blocks}}">
        <sudoku-block value="{{item}}" use-hexadecimal="[[useHexadecimal]]" numbers="[[numbers]]" auto-validate validate="sudoku-section-validator"></sudoku-block>
        <br dom-if="([[index]] % [[numbers]]) === 0">
      </template>
      <sudoku-section-validator validator-name="sudoku-section-validator" numbers="[[numbers]]" use-hexadecimal="[[useHexadecimal]]"></sudoku-section-validator>
      
    </div>
  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
     class SudokuSection extends Polymer.Element {
        static get is() { return 'sudoku-section'; }
        static get properties() {
          return {
              blocks: {
                type: Array,
                value: [],
                observer: '_signalSectorChange'
              },
              numbers: {
                type: Number,
                value: 9,
                observer: '_recalculateWidth'
              },
              useHexadecimal: {
                type: Boolean,
                value: false
              },
              invalidRows: {
                  type: Array,
                  value: []
              },
              invalidColumns: {
                  type: Array,
                  value: []
              }
          };
      }
      _signalSectorChange(newValue, oldValue) {

        console.log('Changed: ', oldValue, newValue);
        if (newValue !== oldValue) {
        }
      }
      _recalculateWidth(newValue, oldValue) {
        if (newValue !== oldValue) {
          var sqrt = Math.sqrt(newValue);
          console.log('_recalculateWidth(...) resizing board for ' + sqrt.toString() + ' sectors.');
          var element = Polymer.dom(this.root).querySelector('.section');
          element.class = 'section size-' + newValue.toString();
        } else {
          console.log('_recalculateWidth(...) skipped. the size is the same.');
        }
      }
      handleInputAdded (evt) {
        console.log('letter added', evt);
      }
      handleInputRemoved (evt) {
        console.log('letter removed', evt);
      }
      handleRowInvalid(evt) {
      }
      handleColumnInvalid(evt) {
      }
      validate(value) {
        console.log('validate in SudokuSection. this should not be used');
        return true;
      }
      constructor() {
        super();
        console.log('constructor');
      }
      ready() {
        super.ready();

        console.log('ready');
        this.addEventListener('inputadded', this.handleInputAdded.bind(this));
        this.addEventListener('inputremoved', this.handleInputRemoved.bind(this));
        this.addEventListener('rowinvalid', this.handleRowInvalid.bind(this));
        this.addEventListener('columninvalid', this.handleColumnInvalid.bind(this));
      }
    }

    class SudokuSectionValidator extends Polymer.mixinBehaviors([Polymer.IronValidatorBehavior],
                                         Polymer.Element) {
      static get is() { return 'sudoku-section-validator'; }
      static get properties () {
        return {
          numbers: {
            type: Number,
            value: 0
          },
          useHexadecimal: {
            type: Boolean,
            value: false
          }
        }
      }
      ready() {
        super.ready();
        console.log('SudokuSectorValidator ready');
        // workaround for polymer 2 validators
        new Polymer.IronMeta({type: 'validator', key: SudokuSectionValidator.is, value: this});
      
      }
      validate(value) {
        console.log('validate section');
        var numbers = this.get('numbers');
        var hasNoDulicates = true;
        var numbers = value.map(this._parse);
        for (var i = 1; i <= numbers; i++) {
          hasNoDuplicates = hasNoDulicates && (value.indexOf(i) == value.lastIndexOf(i));
        }

        return hasNoDulicates;
      }
      _parse(value) {
        var radix = 10;
        if (this.get('useHexadecimal')) {
          radix = 16;
        }

        var newValue = parseInt(value, radix);
        return newValue;
      }
    }

     window.customElements.define(SudokuSection.is, SudokuSection);
     window.customElements.define(SudokuSectionValidator.is, SudokuSectionValidator);
  </script>
</dom-module>