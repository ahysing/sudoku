<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../../bower_components/iron-validator-behavior/iron-validator-behavior.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<dom-module id="sudoku-section">
  <template>
    <style is="custom-style">
      :host {
        @apply --layout-horizontal;
        @apply --layout-wrap;
        border: 1px solid black;
      }
      :host([numbers="4"]) {
        width: 80px;
      }
      :host([numbers="9"]) {
        width: 120px;
      }
      :host([numbers="16"]) {
        width: 160px;
      }
    </style>
    <template is="dom-repeat" items="{{blocks}}" mutable-data>
      <sudoku-block value="{{item}}"
                    is-invalid-section$="{{isInvalidSection}}"
                    is-invalid-row$="[[isInvalidRow]]"
                    is-invalid-col$="[[isInvalidCol]]"
                    index="[[index]]"
                    use-hexadecimal="[[useHexadecimal]]"
                    numbers="[[numbers]]"
                    auto-validate
                    validate="sudoku-section-validator">
      </sudoku-block>
    </template>
  </template>

  <script>
    /**
     * @customElement
     * @polymer
     */
     class SudokuSection extends  Polymer.MutableData(Polymer.Element) {
        static get is() { return 'sudoku-section'; }
        static get properties() {
          return {
              blocks: {
                type: Array,
                value: [],
                notify: true,
                observer: '_signalSectionChange'
              },
              numbers: {
                type: Number
              },
              sectionId: {
                type: Number
              },
              useHexadecimal: {
                type: Boolean,
                value: false
              },
              invalidRows: {
                type: Array,
                value: [],
                notify: true
              },
              invalidCols: {
                type: Array,
                value: [],
                notify: true
              },
              isInvalidSection: {
                type: Boolean,
                value: false,
                notify: true
              },
              isInvalidRow: {
                type: Boolean,
                computed: '_isInvalidRow(invalidRows)'
              },
              isInvalidCol: {
                type: Boolean,
                computed: '_isInvalidColumn(invalidCols)'
              },
          };
      }
      constructor() {
        super();
        console.log('constructor');
      }
      ready() {
        super.ready();
        console.log('ready');
        this.addEventListener('inputadded', this.handleInputAdded.bind(this));
        this.addEventListener('rowchanged', this.handleRowChanged.bind(this));
        this.addEventListener('columnchanged', this.handleColumnChanged.bind(this));
      }
      _signalSectionChange(newValue, oldValue) {
        console.log('_signalSectionChange', oldValue, newValue);
      }
      _isInvalidRow(invalidRows) {
        console.log('_isInvalidRow section', );
      }
      _isInvalidColumn(invalidCols) {
        console.log('_isInvalidCol section', );
      }
      handleInputAdded (evt) {
        console.log('input added', evt.detail);
        this.set('blocks.' + evt.detail.index, evt.detail.value);
        var blocks = this.get('blocks');
        if (!this.validateSection(blocks)) {
          console.warn('failed section', blocks);
          this.set('isInvalidSection', true);
        } else {
          this.set('isInvalidSection', false);
        }
      }
      handleRowChanged(evt) {
        var sectionId = this.get('sectionId');
        
        var detail = evt.detail;
        detail.sectionId = sectionId;
        
        this.dispatchEvent(new CustomEvent('sectionrowchanged', {
              detail: detail,
              bubbles: true,
              cancelable: true,
              composed: true
            }));
      }
      handleColumnChanged(evt) {
        var sectionId = this.get('sectionId');
        
        var detail = evt.detail;
        detail.sectionId = sectionId;
        
        this.dispatchEvent(new CustomEvent('sectioncolumnchanged', {
              detail: detail,
              bubbles: true,
              cancelable: true,
              composed: true
            }));
      }
      validateSection(values) {
        var numbers = this.get('numbers');
        var hasNoDuplicates = true;
        var ints = null;
        if (this.get('useHexadecimal')) {
          ints = values.map(this._parseHex);
        } else {
          ints = values.map(this._parseDec);
        }

        for (var i = 1; i <= numbers; i++) {
          hasNoDuplicates = hasNoDuplicates && (ints.indexOf(i) == ints.lastIndexOf(i));
        }

        return hasNoDuplicates;
      }
      _parseHex(value) {
        var radix = 16;
        var newValue = parseInt(value, radix);
        return newValue;
      }
      _parseDec(value) {
        var newValue = parseInt(value);
        return newValue;
      }
    }

     window.customElements.define(SudokuSection.is, SudokuSection);
  </script>
</dom-module>

<dom-module id="sudoku-block">
  <template>
    <style is="custom-style">
      :host {
        display: block;
      }
      .block {
        width: 40px;
        text-align: center;
        font-size: 2.5em;
      }
      /* TODO: not working */
      paper-input:focus {
        color: blue;
      }
      :host([is-invalid-section]) 
      :host([invalid-row])
      :host([invalid-col])
      {
        background: pink;
        @apply --sudoku-block-invalid-background;
      }
      paper-input {
       /* --paper-input-container-underline: {
          display: none;
       }*/
       --paper-input-container-disabled: {
         opacity: 1;
       }
       --paper-input-container-input-disabled: {
         font-weight: bold;
       }
      }
    </style>
    <sudoku-block-validator numbers="[[numbers]]"
                            use-hexadecimal="[[useHexadecimal]]"
                            is-valid="{{isValidBlock}}">
    </sudoku-block-validator>
    <paper-input class="block"
                 no-label-float
                 auto-validate
                 validator="sudoku-block-validator"
                 value="{{value}}"
                 disabled="[[readOnly]]">
    </paper-input>
  </template>
  
  <script>
    /**
     * @customElement
     * @polymer
     */
    class SudokuBlock extends Polymer.Element {
        static get is() { return 'sudoku-block'; }
        static get properties () {
          return {
            value: {
              type: Number,
              value: null,
              notify: true,
              observer: '_signalBlockChange'
            },
            isInvalidSection: {
              type: Boolean,
              value: false,
              notify: true
            },
            isInvalidRow: {
              type: Boolean,
              computed: '_isInvalidRow(invalidRows)'
            },
            isInvalidCol: {
              type: Boolean,
              computed: '_isInvalidColumn(invalidCols)'
            },
            invalidRows: {
              type: Array,
              value: []
            },
            invalidCols: {
              type: Array,
              value: []
            },
            index: {
              type: Number
            },
            numbers: {
              type: Number
            },
            useHexadecimal: {
              type: Boolean,
              value: false
            },
            readOnly: {
              type: Boolean,
              readOnly: true
            }
          };
        }
        constructor() {
          super();
          console.log('constructor');
        }
        ready() {
          super.ready();
          console.log('ready');
          var value = this.get('value');
          var readOnly = this._detectReadOnlyField(value);
          this.set('readOnly', readOnly);
        }
        _detectReadOnlyField(value) {
          console.log('_detectReadOnlyField(value)', value);
          if (value) {
            return true;
          } else {
            return false;
          }
        }
        _signalBlockChange(newValue, oldValue) {
          console.log('_signalBlockChange', oldValue, newValue);
          const numbers = this.get('numbers');
          const rowsAndColumns = Math.sqrt(numbers);
          const isValid = this.get('isValidBlock');
          if (isValid || isValid === undefined) {
            var value = this.get('value');
            var index = this.get('index');
            var blockParameters = {
              index: index,
              value: value
            };

            this.dispatchEvent(new CustomEvent('inputadded', {
              detail: blockParameters,
              bubbles: true,
              cancelable: true,
              composed: true
            }));

            const rowId = Math.floor(index / rowsAndColumns); 
            const columnId = (index % rowsAndColumns);

            var rowParameters = {
              rowId: rowId,
              value: value
            };

            this.dispatchEvent(new CustomEvent('rowchanged', {
              detail: rowParameters,
              bubbles: true,
              cancelable: true,
              composed: true
            }));
            
            var columnParameters = {
              columnId: columnId,
              value: value
            };

            this.dispatchEvent(new CustomEvent('columnchanged', {
              detail: columnParameters,
              bubbles: true,
              cancelable: true,
              composed: true
            }));
          }
        }
      _isInvalidRow(invalidRows) {
        console.log('_isInvalidRow');
        var index = this.get('index');
        return invalidRows.includes(index);
      }
      _isInvalidColumn(invalidCols) {
        console.log('_isInvalidCol');
        var index = this.get('index');
        return invalidCols.includes(index);  
      }
    }

    class SudokuBlockValidator extends Polymer.mixinBehaviors([Polymer.IronValidatorBehavior, Polymer.MutableData],
                                         Polymer.Element) {
      static get is() { return 'sudoku-block-validator'; }
      static get properties () {
        return {
          numbers: {
            type: Number,
            value: 0
          },
          useHexadecimal: {
            type: Boolean,
            value: false
          },
          isValid: {
            type: Boolean,
            value: true,
            notify: true
          }
        };
      }
      ready() {
        super.ready();
        console.log('SudokuBlockValidator ready');
        // workaround for polymer 2 validators
        new Polymer.IronMeta({type: 'validator', key: SudokuBlockValidator.is, value: this});
      }
      validate(value) {
        // console.log('validate block');
        if (value) {
          var numbers = this.get('numbers');
          var newValue = this._parse(value);
          var isValid = ! isNaN(newValue) && newValue > 0 && newValue <= numbers;
          this.set('isValid', isValid);
          return isValid;
        } else {
          this.set('isValid', isValid);
          return true;
        }
      }
      _parse(value) {
        var radix = 10;
        if (this.get('useHexadecimal')) {
          radix = 16;
        }

        var newValue = parseInt(value, radix);
        return newValue;
      }
    }

    window.customElements.define(SudokuBlock.is, SudokuBlock);
    window.customElements.define(SudokuBlockValidator.is, SudokuBlockValidator);
  </script>
</dom-module>