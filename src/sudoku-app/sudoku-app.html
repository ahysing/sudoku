<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../start-menu/start-menu.html">
<link rel="import" href="../end-menu/end-menu.html">
<link rel="import" href="../sudoku-section/sudoku-section.html">
<dom-module id="sudoku-app">
  <template>
    <style is="custom-style">
      :host {
        display: block;
        }
      .board {
        border: 3px solid black;
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }
      .size-2 {
        width: 164px;
      }
      .size-3 {
        width: 366px;
      }
      .size-4 {
        width: 648px;
      }
    </style>
    <div class="board size">
      <start-menu id="start-menu"></start-menu>
      <end-menu id="end-menu"></end-menu>
      <template is="dom-repeat" items="[[sections]]">
        <sudoku-section id="section-[[index]]"
                        blocks="[[item]]"
                        numbers$="[[numbers]]"
                        use-hexadecimal="[[useHexadecimal]]">
        </sudoku-section>
      </template>
    </div>
  </template>
  <script>
    /**
     * @customElement
     * @polymer
     */
    class SudokuApp extends Polymer.Element {
      static get is() { return 'sudoku-app'; }
      static get properties() {
        return {
          sections: {
            type: Array,
            value: [],
            notify: true
          },
          numbers: {
            type: Number,
            notify: true,
            observer: '_resizeBoard'
          },
          useHexadecimal: {
            type: Boolean,
            value: false
          }
         };
      }
      constructor() {
        super();
      }
      ready() {
        super.ready();
        console.log('sudoku-app ready');
        
        this.addEventListener('closestartmenu', this.handleCloseStartMenu.bind(this));
        this.addEventListener('sectionfilled', this.handleSectionFilled.bind(this));
        var menu = Polymer.dom(this.root).querySelector('start-menu');
        if (menu) {
          menu.dispatchEvent(new CustomEvent('openstartmenu', {
            detail: {},
            bubbles: true,
            cancelable: true
          }));
        }
      }
      _resizeBoard(newValue, oldValue) {
        console.log('resize board');
        switch (newValue) {
          case 4:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-2');
            break;
          case 9:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-3');
            break;
          case 16:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-4');
            break;
          default:
            break;
        }
      }
      getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      setupEasy(sections, numbers, radix) {
        this.setupMedium(sections, numbers, radix);
        this.setupMedium(sections, numbers, radix);
      }
      setupMedium(sections, numbers, radix) {
        sections.forEach(section => {
          var assigned = section.map(function(x) {
            return x === null;
          });
          for (var i = 1; i <= numbers; i++) {
            var idx = this.getRandomInt(0, numbers - 1);
            if (assigned[idx]) {
              section[idx] = i.toString(radix).toUpperCase();
              assigned[i] = false;
            }
          }
        });

        var rowsAndColumns = Math.sqrt(numbers);

        var rowFunc = function (id) {
          return function(section, idx) {
            return Math.floor(idx / rowsAndColumns) === id;
          }
        };
        var colFunc = function (id) {
          return function(section, idx) {
            return (idx % rowsAndColumns) === id;
          }
        };
        var mergeSections = function(sections) {
          var xNoNull = sections.map(function(section) {
            return section.filter(function(x) {
              return x != null;
            });
          });
          return[].concat.apply([], xNoNull);
        }
        for (var i = 0;  i < rowsAndColumns; i++) {
          var sectionsHorizontal = sections.filter(rowFunc(i));
          var sectionsVertical = sections.filter(colFunc(i));
          for (var j = 0; j < rowsAndColumns; j++) {
            var inserted;
            var valuesInRow = sectionsHorizontal.filter(rowFunc(j));
            var allValuesInRow = mergeSections(valuesInRow);
            inserted = new Set(allValuesInRow);
            inserted.delete(null);
            if (inserted.size !== allValuesInRow.length) {
              var removed = new Set(inserted);
              sectionsHorizontal.forEach(function (section, k) {
                for (var k = 0; k < rowsAndColumns; k++) {
                  if (section[k] !== null)
                  {
                    if (removed.has(section[k]))
                    {
                      removed.delete(section[k]);
                    } else {
                      section[k] = null;
                    }
                  }
                }
              });
            }

            var valuesInCol = sectionsVertical.filter(colFunc(j));
            var allValuesInCol = mergeSections(valuesInCol);
            inserted = new Set(allValuesInCol);
            inserted.delete(null);
            if (inserted.size !== allValuesInCol.length) {
              var removed = new Set(inserted);
              sectionsVertical.forEach(function (section, k) {
                for (var k = 0; k < rowsAndColumns; k++) {
                  if (section[k] !== null)
                  {
                    if (removed.has(section[k]))
                    {
                      removed.delete(section[k]);
                    } else {
                      section[k] = null;
                    }
                  }
                }
              });
            }
          }
        }
      }
      setupHard(sections, numbers, radix) {
        var sqrt = Math.sqrt(numbers);
        var indices = Array(numbers).fill(-1);
        var values = Array(numbers).fill(-1);
        var assignedRows = Array(sqrt).fill(true);
        var assignedColumns = Array(sqrt).fill(true);
        var isEmptyRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          return rows[i];
        }

        var isEmptyColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          return columns[i];
        }

        var fillRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          rows[i] = false;
        }

        var fillColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          columns[i] = false;
        }
        
        console.log("applying board");
        for (var i = 0; i < numbers; i++) {
          var idx = -1;
          var value = -1;
          
          var emptyRow, emptyColumn;
          var safeGuardIdx = 0;
          do {
            idx = this.getRandomInt(0, numbers - 1);
            emptyRow = isEmptyRow(assignedRows, idx);
            emptyColumn = isEmptyColumn(assignedRows, idx);
            safeGuardIdx ++;
          } while (safeGuardIdx < numbers && (!emptyRow || !emptyColumn))
          if (safeGuardIdx != numbers) {
            fillRow(assignedRows, idx);
            fillColumn(assignedColumns, idx);
            indices[i] = idx;
          }

          var saveGuardValue = 0;
          do {
            value = this.getRandomInt(1, numbers);
            saveGuardValue ++;
          } while (saveGuardValue < numbers && values.includes(value))
          if (saveGuardValue != numbers) {
            values[i] = value;
          }
        }

        for (var i = 0; i < numbers; i++) {
          var idx = indices[i];
          var value = values[i];
          if (value > 0) {
            sections[i][idx] = value.toString(radix).toUpperCase();
          }
        }
      }
      setupGame(parameters) {
        const difficulty = parameters.difficulty;
        const numbers = parameters.numbers;
        const radix = (parameters.useHexadecimal ? 16 : 10);
        var sections = new Array(numbers);
        for (var i = 0; i < numbers; i++) {
          sections[i] = new Array(numbers);
          sections[i].fill(null);
        }

        switch (difficulty) {
          case 'Easy':
            this.setupEasy(sections, numbers, radix);
            break;
          case 'Medium':
            this.setupMedium(sections, numbers, radix);
            break;
          case 'Hard':
            this.setupHard(sections, numbers, radix);
            break;
          default:
            break;
        }

        this.set('sections', sections);
      }
      validate (evt) {
      }
      handleCloseStartMenu (evt) {
        console.log('handleCloseStartMenu');
        this.set('numbers', evt.detail.numbers);
        this.set('useHexadecimal', evt.detail.useHexadecimal);
        this.setupGame(evt.detail);
      }
      handleSectionFilled(evt) {
        var sections = this.get('sections');
        if (validate(sections)) {

        }
      }
    }

    window.customElements.define(SudokuApp.is, SudokuApp);
  </script>
</dom-module>
