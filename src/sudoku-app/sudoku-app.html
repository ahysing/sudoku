<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../start-menu/start-menu.html">
<link rel="import" href="../end-menu/end-menu.html">
<link rel="import" href="../sudoku-section/sudoku-section.html">
<dom-module id="sudoku-app">
  <template>
    <style is="custom-style">
      :host {
        display: block;
        }
      .board {
        border: 3px solid black;
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }
      .size-2 {
        width: 164px;
      }
      .size-3 {
        width: 366px;
      }
      .size-4 {
        width: 648px;
      }
    </style>
    <div class="board size">
      <start-menu id="start-menu"></start-menu>
      <end-menu id="end-menu"></end-menu>
      <template is="dom-repeat" items="[[sections]]">
        <sudoku-section id="section-[[index]]" blocks="[[item]]" numbers$="[[numbers]]" use-hexadecimal="[[useHexadecimal]]"></sudoku-section>
      </template>
    </div>
  </template>
  <script>
    /**
     * @customElement
     * @polymer
     */
    class SudokuApp extends Polymer.Element {
      static get is() { return 'sudoku-app'; }
      static get properties() {
        return {
          sections: {
            type: Array,
            value: [],
            notify: true
          },
          numbers: {
            type: Number,
            notify: true,
            observer: '_resizeBoard'
          },
          useHexadecimal: {
            type: Boolean,
            value: false
          }
         };
      }
      constructor() {
        super();
      }
      ready() {
        super.ready();
        console.log('sudoku-app ready');
        
        this.addEventListener('closestartmenu', this.handleCloseStartMenu.bind(this));
        this.addEventListener('sectionfilled', this.handleSectionFilled.bind(this));
        var menu = Polymer.dom(this.root).querySelector('start-menu');
        if (menu) {
          menu.dispatchEvent(new CustomEvent('openstartmenu', {
            detail: {},
            bubbles: true,
            cancelable: true
          }));
        }
      }
      _resizeBoard(newValue, oldValue) {
        console.log('resize board');
        switch (newValue) {
          case 4:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-2');
            break;
          case 9:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-3');
            break;
          case 16:
            Polymer.dom(this.root).querySelector('.board').classList.add('size-4');
            break;
          default:
            break;
        }
      }
      getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      setupEasy(sections, numbers) {
        this.setupHard(sections, numbers);
      }
      setupMedium(sections, numbers) {
        this.setupHard(sections, numbers);
      }
      setupHard(sections, numbers) {
        var sqrt = Math.sqrt(numbers);
        var indices = Array(numbers).fill(-1);
        var values = Array(numbers).fill(-1);
        var assignedRows = Array(sqrt).fill(true);
        var assignedColumns = Array(sqrt).fill(true);
        
        var isEmptyRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          return rows[i];
        }

        var isEmptyColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          return columns[i];
        }

        var fillRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          rows[i] = false;
        }

        var fillColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          columns[i] = false;
        }
        
        for (var i = 0; i < sqrt; i++) {
          var idx = -1;
          var value = -1;
          
          var emptyRow, emptyColumn;
          do {
            idx = this.getRandomInt(0, numbers - 1);
            emptyRow = isEmptyRow(assignedRows, idx);
            emptyColumn = isEmptyColumn(assignedRows, idx);
          } while (!emptyRow || !emptyColumn);
          fillRow(assignedRows, idx);
          fillColumn(assignedColumns, idx);
          indices[i] = idx;

          do {
            value = this.getRandomInt(1, numbers);
          } while (values.includes(value))
          values[i] = value
        }

        for (var i = 0; i < numbers; i++) {
          var idx = indices[i];
          var value = values[i];
          if (value > 0) {
            sections[i][idx] = value;
          }
        }
      }
      setupGame(parameters) {
        const difficulty = parameters.difficulty;
        const numbers = parameters.numbers;

        var sections = new Array(numbers);
        for (var i = 0; i < numbers; i++) {
          sections[i] = new Array(numbers);
          sections[i].fill(null);
        }

        switch (difficulty) {
          case 'Easy':
            this.setupEasy(sections, numbers);
            break;
          case 'Medium':
            this.setupMedium(sections, numbers);
            break;
          case 'Hard':
            this.setupHard(sections, numbers);
            break;
          default:
            break;
        }

        this.set('sections', sections);
      }
      validate (evt) {
      }
      handleCloseStartMenu (evt) {
        console.log('handleCloseStartMenu');
        this.set('numbers', evt.detail.numbers);
        this.set('useHexadecimal', evt.detail.useHexadecimal);
        this.setupGame(evt.detail);
      }
      handleSectionFilled(evt) {
        var sections = this.get('sections');
        if (validate(sections)){

        }
      }
    }

    window.customElements.define(SudokuApp.is, SudokuApp);
  </script>
</dom-module>
