<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../start-menu/start-menu.html">
<link rel="import" href="../end-menu/end-menu.html">
<link rel="import" href="../sudoku-section/sudoku-section.html">
<dom-module id="sudoku-app">
  <template>
    <style is="custom-style">
      :host {
        display: block;
        }
      .board {
        border: 3px solid black;
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }
      .size-2 {
        width: 164px;
      }
      .size-3 {
        width: 366px;
      }
      .size-4 {
        width: 648px;
      }
    </style>
    <div class="board">
      <start-menu id="start-menu"></start-menu>
      <end-menu id="end-menu" open="[[wonGame]]"></end-menu>
      <template is="dom-repeat" items="[[sections]]">
        <sudoku-section section-id="[[index]]"
                        blocks="[[item.values]]"
                        numbers="[[numbers]]"
                        invalid-rows$="[[item.invalidRows]]"
                        invalid-cols$="[[item.invalidCols]]"
                        use-hexadecimal="[[useHexadecimal]]">
        </sudoku-section>
      </template>
    </div>
  </template>
  <script>
    /**
     * @customElement
     * @polymer
     */
    class SudokuApp extends Polymer.Element {
      static get is() { return 'sudoku-app'; }
      static get properties() {
        return {
          sections: {
            type: Array,
            value: [],
            notify: true
          },
          numbers: {
            type: Number,
            notify: true,
            observer: '_resizeBoard'
          },
          useHexadecimal: {
            type: Boolean,
            value: false
          },
          invalidCols: {
            type: Array,
            value: [],
            notify: true
          },
          wonGame: {
            type: Boolean,
            computed: '_hasWonGame(sections)'
          }
        };
      }
      constructor() {
        super();
      }
      ready() {
        super.ready();
        console.log('sudoku-app ready');
        
        this.addEventListener('closestartmenu', this.handleCloseStartMenu.bind(this));
        this.addEventListener('sectionrowchanged', this.handleSectionRowChanged.bind(this));
        this.addEventListener('sectioncolumnchanged', this.handleSectionColumnChanged.bind(this));
        var menu = Polymer.dom(this.root).querySelector('start-menu');
        if (menu) {
          menu.dispatchEvent(new CustomEvent('openstartmenu', {
            detail: {},
            bubbles: true,
            cancelable: true
          }));
        }
      }
      _resizeBoard(newValue, oldValue) {
        switch (newValue) {
          case 4:
            var elem = Polymer.dom(this.root).querySelector('.board');
            elem.classList.remove('size-3');
            elem.classList.remove('size-4');
             elem.classList.add('size-2');
            break;
          case 9:
            var elem = Polymer.dom(this.root).querySelector('.board');
            elem.classList.remove('size-2');
            elem.classList.remove('size-4');
            elem.classList.add('size-3');
            break;
          case 16:
            var elem = Polymer.dom(this.root).querySelector('.board');
            elem.classList.remove('size-2');
            elem.classList.remove('size-3');
            elem.classList.add('size-4');
          break;
          default:
            break;
        }
      }
      _hasWonGame(sections) {
        var invalidRows = sections.invalidRows;
        var invalidCols = sections.invalidCols;
        if(invalidRows && invalidCols && invalidRows.length === 0 && invalidCols.length === 0) {
          var allFilled = sections.every(sec => sec.every(value => value !== null));
          if (allFilled) {
            var validSections = sections.every(sec => this.isValid(sec));
            return validSections;
          }
        } else {
          return false;
        }
      }
      getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      setupEasy(sections, numbers, radix) {
        this.setupMedium(sections, numbers, radix);
        this.setupMedium(sections, numbers, radix);
      }
      setupMedium(sections, numbers, radix) {
        const rowsAndColumns = Math.sqrt(numbers);
        const rowFunc = function (id) {
          return function(section, idx) {
            return Math.floor(idx / rowsAndColumns) === id;
          }
        };

        const colFunc = function (id) {
          return function(section, idx) {
            return (idx % rowsAndColumns) === id;
          }
        };

        var assignedValues = new Array(numbers);
        for (var i = 0; i < sections.length; i++) {
          var sec = sections[i];
          var values = sec.values;
          assignedValues[i] = values.map(function(x) {
            return x === null;
          });
        }

        var assignedRows = Array(numbers).fill(Array(numbers));
        var assignedColumns = Array(numbers).fill(Array(numbers));        
        sections.forEach((section, sectionId) => {
          for (var value = 1; value <= numbers; value++) {
            var assigned = assignedValues[sectionId];
            var idx = this.getRandomInt(0, numbers - 1);
            if (assigned[idx]) {
              var rowsInLine = assignedRows.filter(rowFunc(sectionId));
              var colsInLine = assignedColumns.filter(colFunc(sectionId));
              if (
                rowsInLine.every(function(row, allignId)
                {
                  return row[value];
                })
                && colsInLine.every(function(col, allignId)
                {
                  return col[value];
                })
              ) {
                section.values[idx] = value.toString(radix).toUpperCase();
                
                // remove all values in adjacent rows, columns and current section
                assigned[value] = false;
                for (var i = 0; i < rowsInLine.length; i++) {
                  rowsInLine[value] = false
                }

                for (var i = 0; i < colsInLine.length; i++) {
                  colsInLine[value] = false
                }
              }
            }
          }
        });
        /*
        var mergeSections = function(sections) {
          var xNoNull = sections.map(function(section) {
            return section.filter(function(x) {
              return x != null;
            });
          });
          return[].concat.apply([], xNoNull);
        }
        for (var i = 0;  i < rowsAndColumns; i++) {
          var sectionsHorizontal = sections.filter(rowFunc(i));
          var sectionsVertical = sections.filter(colFunc(i));
          for (var j = 0; j < rowsAndColumns; j++) {
            var inserted;
            var valuesInRow = sectionsHorizontal.filter(rowFunc(j));
            var allValuesInRow = mergeSections(valuesInRow);
            inserted = new Set(allValuesInRow);
            inserted.delete(null);
            if (inserted.size !== allValuesInRow.length) {
              var removed = new Set(inserted);
              sectionsHorizontal.forEach(function (section, k) {
                for (var k = 0; k < rowsAndColumns; k++) {
                  if (section[k] !== null)
                  {
                    if (removed.has(section[k]))
                    {
                      removed.delete(section[k]);
                    } else {
                      section[k] = null;
                    }
                  }
                }
              });
            }

            var valuesInCol = sectionsVertical.filter(colFunc(j));
            var allValuesInCol = mergeSections(valuesInCol);
            inserted = new Set(allValuesInCol);
            inserted.delete(null);
            if (inserted.size !== allValuesInCol.length) {
              var removed = new Set(inserted);
              sectionsVertical.forEach(function (section, k) {
                for (var k = 0; k < rowsAndColumns; k++) {
                  if (section[k] !== null)
                  {
                    if (removed.has(section[k]))
                    {
                      removed.delete(section[k]);
                    } else {
                      section[k] = null;
                    }
                  }
                }
              });
            }
          }
        }
        */
      }
      setupHard(sections, numbers, radix) {
        var sqrt = Math.sqrt(numbers);
        var indices = Array(numbers).fill(-1);
        var values = Array(numbers).fill(-1);
        var assignedRows = Array(sqrt).fill(true);
        var assignedColumns = Array(sqrt).fill(true);
        var isEmptyRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          return rows[i];
        }

        var isEmptyColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          return columns[i];
        }

        var fillRow = function (rows, idx) {
          var i = Math.floor(idx / sqrt);
          rows[i] = false;
        }

        var fillColumn = function (columns, idx) {
          var i = Math.floor(idx % sqrt);
          columns[i] = false;
        }
        
        console.log("applying board");
        for (var i = 0; i < numbers; i++) {
          var idx = -1;
          var value = -1;
          
          var emptyRow, emptyColumn;
          var safeGuardIdx = 0;
          do {
            idx = this.getRandomInt(0, numbers - 1);
            emptyRow = isEmptyRow(assignedRows, idx);
            emptyColumn = isEmptyColumn(assignedRows, idx);
            safeGuardIdx ++;
          } while (safeGuardIdx < numbers && (!emptyRow || !emptyColumn))
          if (safeGuardIdx != numbers) {
            fillRow(assignedRows, idx);
            fillColumn(assignedColumns, idx);
            indices[i] = idx;
          }

          var saveGuardValue = 0;
          do {
            value = this.getRandomInt(1, numbers);
            saveGuardValue ++;
          } while (saveGuardValue < numbers && values.includes(value))
          if (saveGuardValue != numbers) {
            values[i] = value;
          }
        }

        for (var i = 0; i < numbers; i++) {
          var idx = indices[i];
          var value = values[i];
          if (value > 0) {
            sections[i][idx] = value.toString(radix).toUpperCase();
          }
        }
      }
      setupGame(parameters) {
        const difficulty = parameters.difficulty;
        const numbers = parameters.numbers;
        const radix = (parameters.useHexadecimal ? 16 : 10);
        var sections = new Array(numbers);
        for (var i = 0; i < numbers; i++) {
          sections[i] = {
            values: new Array(numbers).fill(null),
            invalidRows: [],
            invalidCols: []
          };
        }

        switch (difficulty) {
          case 'Easy':
            this.setupEasy(sections, numbers, radix);
            break;
          case 'Medium':
            this.setupMedium(sections, numbers, radix);
            break;
          case 'Hard':
            this.setupHard(sections, numbers, radix);
            break;
          default:
            break;
        }

        this.set('sections', sections);
      }
      validate (evt) {
      }
      handleCloseStartMenu (evt) {
        console.log('handleCloseStartMenu');
        this.set('numbers', evt.detail.numbers);
        this.set('useHexadecimal', evt.detail.useHexadecimal);
        this.setupGame(evt.detail);
      }
      isValid(values) {
        var numbers = this.get('numbers');
        var hasNoDuplicates = true;
        var ints = null;
        if (this.get('useHexadecimal')) {
          ints = values.map(this._parseHex);
        } else {
          ints = values.map(this._parseDec);
        }

        for (var i = 1; i <= numbers; i++) {
          hasNoDuplicates = hasNoDuplicates && (ints.indexOf(i) == ints.lastIndexOf(i));
        }

        return hasNoDuplicates;
      }
      _parseHex(value) {
        var radix = 16;
        var newValue = parseInt(value, radix);
        return newValue;
      }
      _parseDec(value) {
        var newValue = parseInt(value);
        return newValue;
      }
      handleSectionRowChanged(evt) {
        const sections = this.get('sections');
        const numbers = this.get('numbers');
        const row = this.extractAffectedRow(sections, numbers, evt.detail);
        if (!this.isValid(row.values)) {
          console.warn('failed row', row.values);
          for (var it = 0; it < row.sectionIds.length; it++) {
            var i = row.sectionIds[it];
            var irArr = this.get(['sections', i, 'invalidRows']);
            var ir = new Set(irArr);
            if (ir.add(row.rowId)) {  
              this.set(['sections', i, 'invalidRows'], Array.from(ir));
            }
          }
        } else {
          for (var it = 0; it < row.sectionIds.length; it++) {
            var i = row.sectionIds[it];
            var irArr = this.get(['sections', i, 'invalidRows']);
            var ir = new Set(irArr);
            if (ir.delete(row.rowId)) {  
              this.set(['sections', i, 'invalidRows'], Array.from(ir));
            }
          }
        }
      }
      handleSectionColumnChanged(evt) {
        const sections = this.get('sections');
        const numbers = this.get('numbers');
        var column = this.extractAffectedColumn(sections, numbers, evt.detail);
        if (!this.isValid(column.values)) {
          console.warn('failed column', column.values);
          for (var it = 0; it < column.sectionIds.length; it++) {
            var i = column.sectionIds[it];
            var icArr = this.get(['sections', i, 'invalidCols']);
            var ic = new Set(icArr);
            if (ic.add(column.columnId)) {  
              this.set(['sections', i, 'invalidCols'], Array.from(ic));
            }
          }
        } else {
          for (var it = 0; it < column.sectionIds.length; it++) {
            var i = column.sectionIds[it];
            var icArr = this.get(['sections', i, 'invalidCols']);
            var ic = new Set(icArr);
            if (ic.delete(column.columnId)) {  
              this.set(['sections', i, 'invalidCols'], Array.from(ic));
            }
          };
        }
      }
      getValueAndIndex(x, i) {
        return {
          instance: x,
          i: i
        };
      }
      extractAffectedRow (sections, numbers, inputEvent) {
        const sectionFunc = function (id, rowsAndColumns) {
          const row = Math.floor(id / rowsAndColumns);
          return function(_, i) {
            return Math.floor(i / rowsAndColumns) === row;
          }
        };
        
        const sectionId = inputEvent.sectionId;
        const rowsAndColumns = Math.sqrt(numbers);
        const affectedSections = sections.map(this.getValueAndIndex).filter(sectionFunc(sectionId, rowsAndColumns));
        const rowIndices = Array.from(Array(rowsAndColumns)).map((_, i) => i + inputEvent.rowId * rowsAndColumns);
        var initial = {
          rowId: inputEvent.rowId,
          sectionIds: [],
          values: []
        };

        const row = affectedSections.reduce(function(accumulator, sec) {
          accumulator.sectionIds.push(sec.i);
          sec.instance.values.forEach(function(x, i) {
            if (rowIndices.includes(i)) {
                if (x !== null) {
                accumulator.values.push(x);
              }
            }
          });

          return accumulator;
        }, initial);

        return row;
      }
      extractAffectedColumn(sections, numbers, inputEvent) {
        const sectionFunc = function (id, rowsAndColumns) {
          const column = (id % rowsAndColumns);
          return function(_, i) {
            return (i % rowsAndColumns) === column;
          }
        };

        const sectionId = inputEvent.sectionId;
        const rowsAndColumns = Math.sqrt(numbers);
        const affectedSections = sections.map(this.getValueAndIndex).filter(sectionFunc(sectionId, rowsAndColumns));
        const blockIndices = Array.from(Array(rowsAndColumns)).map((_, i) => inputEvent.columnId + i * rowsAndColumns);
        var initial = {
          columnId: inputEvent.columnId,
          sectionIds: [],
          values: []
        };

        const column = affectedSections.reduce(function(accumulator, sec) {
          accumulator.sectionIds.push(sec.i);
          sec.instance.values.forEach(function(x, i) {
            if (blockIndices.includes(i)) {
              if (x !== null) {
                accumulator.values.push(x);
              }
            }
          });

          return accumulator;
        }, initial);
          
        return column;
      }
    }

    window.customElements.define(SudokuApp.is, SudokuApp);
  </script>
</dom-module>
